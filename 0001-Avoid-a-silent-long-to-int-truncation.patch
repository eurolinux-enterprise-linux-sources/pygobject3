From 060dbac3d191cacc558d7ee5fcd6f3e38de48dd6 Mon Sep 17 00:00:00 2001
From: Rui Matos <tiagomatos@gmail.com>
Date: Thu, 21 May 2015 17:53:17 +0200
Subject: [PATCH] Avoid a silent long to int truncation

If the python object contains a value bigger than MAXUINT we'd
silently truncate it when assigning to 'val' and the if condition
would always be true.

This was caught but a coverity scan.

https://bugzilla.gnome.org/show_bug.cgi?id=749698
---
 gi/pygi-value.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gi/pygi-value.c b/gi/pygi-value.c
index 9d5d0ca..7fdf767 100644
--- a/gi/pygi-value.c
+++ b/gi/pygi-value.c
@@ -382,7 +382,7 @@ pyg_value_from_pyobject_with_error(GValue *value, PyObject *obj)
     case G_TYPE_UINT:
     {
         if (PYGLIB_PyLong_Check(obj)) {
-            guint val;
+            gulong val;
 
             /* check that number is not negative */
             if (PyLong_AsLongLong(obj) < 0)
@@ -390,7 +390,7 @@ pyg_value_from_pyobject_with_error(GValue *value, PyObject *obj)
 
             val = PyLong_AsUnsignedLong(obj);
             if (val <= G_MAXUINT)
-                g_value_set_uint(value, val);
+                g_value_set_uint(value, (guint) val);
             else
                 return -1;
         } else {
-- 
2.4.0

